#include "charboard.hpp"
#include "macros.hpp"
#include <vector>

using namespace std;

class CharBoardOps
{
public:
    /// @brief Give the starting board of the game as a charboard
    /// @return charboard
    CB* initialBoard()
    {
        // Fuck it I'm hard coding them. Looks shit otherwise.
        CB initial =   {'r', 'n', 'b', 'q', 'k', 'b', 'n', 'r',
                        'p', 'p', 'p', 'p',' p', 'p', 'p', 'p',
                        '.', '.', '.', '.', '.', '.', '.', '.',
                        '.', '.', '.', '.', '.', '.', '.', '.',
                        '.', '.', '.', '.', '.', '.', '.', '.',
                        '.', '.', '.', '.', '.', '.', '.', '.',
                        'P', 'P', 'P', 'P', 'P', 'P', 'P', 'P',
                        'R', 'N', 'B', 'Q', 'K', 'B', 'N', 'R'};
        
        return &initial;
    };

    vector<CB*> generateBlackMoves(CB *board) {
        vector<CB*> results;

        for (int i = 0; i < BOARD_SIZE; i++) {
            switch(*board[i]) {
                case CB_BLACK_PAWN:
                    addBlackPawnMoves(&results, board, i);
                    break;
                case CB_BLACK_KNIGHT:
                    // addBlackKnightMoves(&results, board, i);
                    break;
                case CB_BLACK_BISHOP:
                    // addBlackBishopMoves(&results, board, i);
                    break;
                case CB_BLACK_ROOK:
                    // addBlackRookMoves(&results, board, i);
                    break;
                case CB_BLACK_QUEEN:
                    // addBlackQueenMoves(&results, board, i);
                    break;
                case CB_BLACK_KING:
                    // addBlackKingMoves(&results, board, i);
                    break;
            };
        }

    }

    CB** generateWhiteMoves() {

    }

    /// @brief Add the boards which result from a black pawn at 'pos' making a move. Generated by ChatGPT.
    /// @param results 
    /// @param board 
    /// @param pos 
    void addBlackPawnMoves(vector<CB*> *results, CB *board, int pos) {
        // Check row 
        int row = pos / BOARD_WIDTH;
        int col = pos % BOARD_WIDTH;
        if (row == 1 && *board[pos + 2*BOARD_WIDTH] == EMPTY && *board[pos + BOARD_WIDTH] == EMPTY) // Double move from starting position
        {
            CB *move = copyBoard(board);
            (*move)[pos] = EMPTY;
            (*move)[pos + 8] = EMPTY;
            (*move)[pos + 16] = CB_BLACK_PAWN;
            results->push_back(move);
        }
        if (*board[pos + BOARD_WIDTH] == EMPTY) // Regular single move
        {
            CB *move = copyBoard(board);
            (*move)[pos] = EMPTY;
            char new_piece = CB_BLACK_PAWN;
            if (row == 6) {
                new_piece = CB_BLACK_QUEEN; // Promotion case
            }
            (*move)[pos + 8] = new_piece;
            results->push_back(move);
        }
        if (*board[pos + 7] >= 'A' && col != 0) // capture to the left
        {
            CB *move = copyBoard(board);
            (*move)[pos] = EMPTY;
            (*move)[pos + 7] = CB_BLACK_PAWN;
            results->push_back(move);
        }
        if (*board[pos + 9] >= 'A' && col != 7) // capture to the right
        {
            CB *move = copyBoard(board);
            (*move)[pos] = EMPTY;
            (*move)[pos + 9] = CB_BLACK_PAWN;
            results->push_back(move);
        }
    }

    CB* copyBoard(CB* oldboard) {
        CB newboard;
        for (int i = 0; i < BOARD_SIZE; i++) {
            newboard[i] = *oldboard[i];
        }
        return &newboard;
    }
};
